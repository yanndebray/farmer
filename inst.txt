Getting Started

This window contains information about everything in the game.

You can move windows around by dragging and dropping the gray part of the window.
You can move around by dragging anywhere outside the windows.

To start programming, go to the "First Program" page by pressing the following 

---

First Program

All programming is done in code windows. Each code window corresponds to a text file containing code. 
The code can be edited like in any text editor as long as it's not running.
You can execute the program directly by pressing the green play button in the code window.

When you run a program the code flashes so you can see the execution flow.

You can create more code files using the "+" button in the upper right corner of the screen.
You can dock a window to another window by dragging it onto it.

You will notice that once you start typing, a simple code completion window will pop up.
Press Tab to insert the code completion.
Use the arrow keys to navigate through the completion options.

Don't worry if this is your first time programming. The language is unlocked step by step, so you won't be overwhelmed by all the things you can do. 
The syntax is also similar to that of Python, which is one of the most widely used programming languages in the world, so learning it is not completely wasted.

If you already know Python, it's not a problem either, you'll just be able to skip the early game quickly to get to the more interesting stuff.

Code is a sequence of statements that are executed line by line.

Currently, the only statements available are

harvest()

and 

do_a_flip()

These are function calls. A function is essentially a piece of functionality that can be executed. You execute it using the () parentheses.

Try typing these statements in the code window and pressing the execute button.

Unlocks

Collecting grass will give you hay. Hay can be used to unlock loops in the unlock menu. Open the unlock menu with the button in the top right corner.

---

Move Drone

Your farm has grown! This space is not much use if you can't move the drone, so there is a new function move() that moves the drone. move() requires that you specify the direction in which you want the drone to move. There are four new constants for this: North, East, South, West

For example, move(North) will move the drone one square to the north.

If you move over the edge of the farm the drone will be moved to the other side of the farm.
The following example code will keep moving north and wrap back to the start when it reaches the edge of the farm:

while True:
	move(North)

---

Plants

Grass is nice because it grows automatically. All other plants have to be planted with the plant() function. The only plant you can plant right now is a bush.
You can pass the type of plant you want to plant to the function like this:

plant(Entities.Bush)

This will plant a bush under the drone.

Call clear() to reset the farm to all grass and reset the drone position.

---

For Loop

Your farm has expanded again! Now the tiles are no longer in a nice row, so you need to find a way to traverse a square grid.

With the while loop this is simply not possible (at least until you unlock senses).
It is time to introduce the for loop.

The for loop works just like the for loop in Python. (Called a foreach loop in some languages, not to be confused with the C-style for loop, which is a different thing). 
It must be given a sequence to iterate over:

for i in sequence:
	#do something with i

Currently the only way to get such a sequence is through the range() function. 
range(n) returns a sequence containing numbers from 0 to n(exclusive) in steps of 1.
range(start, end) returns a sequence containing numbers from start to end(exclusive) in steps of 1.
range(start, end, step_size) returns a sequence containing numbers from start to end(exclusive) in steps of step_size.

So what's mainly useful right now is being able to run some code exactly n times like this:

#do n flips
for i in range(n):
	do_a_flip()

The function get_world_size() is also available now. It returns the side length of your farm. This way you can write code that won't break with the next expand upgrade.

If you're stuck on trying to figure out how to move the drone around the farm click the spoiler for a hint.

There are, of course, several ways to move around the farm.
What we're looking for is a way to traverse it in a systematic way that won't break when the farm grows again.
A systematic way to get to every place on the farm would be to repeat the following 2 steps forever:

1.Move North until it wraps back.
2.Move East

for i in range(get_world_size()): may be helpful to turn this idea into code.

The basic traversal might look like this:

for i in range(get_world_size()):
	for j in range(get_world_size()):
		#do a flip on every tile
		do_a_flip()
		move(North)
	move(East)

---

Senses

The drone can see now! 

The functions get_pos_x() and get_pos_y() return the current x and y position of the drone. At the start position they are both 0. The x position increases by 1 every tile towards East and the y position increases by 1 every tile towards North.

num_items(item) returns how many of an item you have.
For example num_items(Items.Hay) returns how much hay you have.

get_entity_type() and get_ground_type() return the type of entity or ground that is under the drone. Once you have unlocked Operators you can check if the drone is over a specific entity or ground:

Do a flip if you are over a bush:
if get_entity_type() == Entities.Bush:
	do_a_flip()

The None keyword is also unlocked now! None is a value that represents that there is no value.
For example, a function that has no return statement will actually return None.

get_entity_type() returns None if there is no entity under the drone.

---

Carrots

Before you can plant carrots with plant(Entities.Carrots), you have to do two new things. First, carrots can only grow on tilled soil. To till the soil, simply call till(). Calling till() again will change it back to Grounds.Turf.

The second new feature is that carrots need seeds to grow. You can buy carrot seeds with the new trade() function.
You have to pass an item type to trade() like this: trade(Items.Carrot_Seed)

If the item can be bought, then it will be bought with this.

You can see the cost of any item in its tooltip. The tooltip appears when you mouse over the item itself or the item name in the code.

---

Pumpkins

Pumpkins grow like carrots on tilled soil. They require pumpkin seeds to be planted, which cost one carrot each.

When all the pumpkins in a field are fully grown, they grow together to form a giant pumpkin. The yield of a giant pumpkin is the cubed side length of the pumpkin.

A 2x2 pumpkin yields 2*2*2 = 8 pumpkins instead of 4
A 3x3 pumpkin yields 3*3*3 = 27 pumpkins instead of 9
A 4x4 pumpkin yields 4*4*4 = 64 pumpkins instead of 16
...

It's a good idea to get the pumpkins as big as possible before harvesting. The problem is that about 1 in 5 pumpkins will die before they grow up. This means that even if you plant a pumpkin on every tile in a square, one of the pumpkins may die and prevent the mega pumpkin from growing. A pumpkin that dies will simply disappear so you can plant a new one.

---

Trees

Trees are a better way to get wood than bushes. They give 5 wood each. Like bushes, they can be planted on grass or soil.

Trees like to have some space and planting them right next to each other will slow down their growth. The growing time is doubled for each tree that is on a tile directly to the North, East, West or South of it. So if you plant trees on every tile, they will take 2*2*2*2 = 16 times longer to grow.

 The % operator can be useful here. Remember that the % operator returns the remainder of the division. Even numbers divided by 2 have a remainder of 0 and odd numbers divided by 2 have a remainder of 1.
So you can check if a number is even like this:

def is_even(n):
	return n % 2 == 0

This returns True if n is even and False if it isn't.

---

Sunflowers

Sunflowers collect the power of the sun. You can harvest that power. 

Planting them works exactly the same way as planting carrots, except you have to buy sunflower seeds instead of carrot seeds. 

However, when you harvest a sunflower, the power of all the sunflowers on the farm flows together into the harvested plant. 
Thus, harvesting a sunflower yields power equal to the square root of the number of sunflowers on the farm.
Only one of the sunflowers with the most petals can handle this.
If you harvest a sunflower that doesn't have the most petals of all the sunflowers on the farm the power will destroy all the sunflowers on the farm.

measure() returns the number of petals of the sunflower under the drone.

Several sunflowers can have the same number of petals so there can also be several sunflowers with the largest number of petals. In this case, it doesn't matter which one of them you harvest.

As long as you have power the drone will use it to run twice as fast. 
It consumes 1 power every 30 actions (like moves, harvests, plants...)
Executing other code statements can also use power but a lot less than drone actions.

In general, everything that is sped up by speed upgrades is also sped up by power.
Anything sped up by power also uses power proportional to the time it takes to execute it, ignoring speed upgrades.

---

Fertilizer

At some point, waiting for the plants to grow is just not efficient enough anymore. 
Fertilizer can make plants grow much faster. use_item(Items.Fertilizer) will instantly grow the plant under the drone by 2 seconds.
Fertilizer can be bought with trade(Items.Fertilizer).

Using fertilizer dries up the ground. The water speed buff will still apply while the fertilizer is being used, but after that, the water level on the ground will be reduced to 0.

---

Mazes

f you use fertilizer on a full-grown bush, it will grow into a maze of hedges with a 10% probability. For some reason the drone can't fly over the hedges, even though they don't look that high.

There is a treasure hidden somewhere in the hedge. Use harvest() on the treasure to receive gold equal to the area of the maze. (For example, a 5x5 maze will yield 25 gold.)

If you use harvest() anywhere else the maze will simply disappear.

get_entity_type() is equal to Entities.Treasure if the drone is over the treasure and Entities.Hedge everywhere else in the maze.

Mazes do not contain any loops unless you reuse the maze (see below how to reuse a maze). So there is no way for the drone to end up in the same position again without going back.

You can check if there is a wall by trying to move through it. 
move() returns True if it succeeded and False otherwise.
If you have no idea how to get to the treasure, take a look at Hint 1. It shows you how to approach a problem like this.

For an extra challenge you can also reuse the maze by using fertilizer on the treasure. 
This has a 10% probability of increasing the treasure by one full maze and moving it to a random position in the maze.
Using measure() on a treasure returns the position it will go to next as a tuple (x_position, y_position).

For example, while above the treasure, the following code gives you the position where the treasure will be after you fertilize it:
next_x, next_y = measure()

Each time the treasure is relocated a random wall may be removed from the maze. So reused mazes can contain loops.

Note that loops in the maze make it much more difficult so if you are a beginner you may not want to reuse mazes. Reusing mazes doesn't give you more gold than spawning a new maze. It's only worth it if the extra information and the shortcuts help you solve the maze faster.

The same maze can be solved a maximum of 300 times. This corresponds to 299 relocations. After that, fertilizing the treasure won't have any effect anymore.

Here's a general approach to solving the problem:

Create a maze and imagine that you are the drone.

Think about how you would try to find the treasure if you were in the maze.

Write down your strategy step by step so that someone else could follow it without thinking.

Now try translating your steps into code.

For mazes without cycles: All the walls are really just one large connected wall. If you follow the wall, it will lead you through the whole maze.

It may be helpful to keep track of the direction the drone is going. The following index trick could be helpful for this:

directions = [North, East, South, West]
index = 0

# rotate right
# the % 4 makes it wrap around
index = (index + 1) % 4

# rotate left
index = (index - 1) % 4

move(directions[index])

If you can't solve it, you can always make your life easy and do it less efficiently. 
You don't have to be able to reach the treasure every time, you can always harvest and spawn a new maze.
There is even a small chance that the treasure will appear right under the drone when you create a maze.